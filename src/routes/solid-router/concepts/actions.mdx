---
title: "Actions"
---

Actions simplify handling data mutations and side effects in your applications.
They are ideal for handling form submissions, API calls, and other updates that modify your application's state on the server or client.

Actions provide several benefits:

- **Integrated state management:**
  Solid Router automatically tracks the execution state of an action (pending, successful, error), simplifying reactive UI feedback.
- **Automatic data revalidation:**
  After an action successfully completes, Solid Router revalidates relevant queries that are used on the same page.
  This ensures your UI reflects the latest data without manual intervention.
- **Progressive enhancement:**
  When used with HTML forms, actions enable functionality even if JavaScript is not yet loaded.

## Defining actions

At their core, actions are **asynchronous operations**.
You define them by wrapping your asynchronous logic with the [`action`](/solid-router/reference/data-apis/action) function.
When the action is invoked, Solid Router executes your defined logic.

```tsx
import { action } from "@solidjs/router";

const addPostAction = action(async (title: string) => {
	const response = await fetch("https://api.com/posts", {
		method: "POST",
		headers: {
			"Content-Type": "application/json",
		},
		body: JSON.stringify({ title }),
	});

	if (!response.ok) {
		const errorData = await response.json();
		return { ok: false, message: errorData.message };
	}

	return { ok: true };
});
```

In this example, `addPostAction` sending a POST request to create a new post.
If the request failed, it returns an error.
We will cover error handling later in this page.

## Invoking actions

You can invoke an action in two primary ways: through an HTML `<form>` or programmatically with the `useAction` primitive.

The recommended approach for any operation that involves changing data is to use a `<form>`.
This ensures your application works even before any client-side JavaScript has loaded, providing a robust user experience through [progressive enhancement](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement).

For cases where a form is not suitable, you can use the `useAction` primitive to invoke the action programmatically.

### With the `<form>` element

Solid Router extends the standard HTML `<form>` element to work with actions.
By passing an action to the `action` prop, you can handle form submissions seamlessly.

Consider these points when using actions with `<form>`:

1. The `<form>` element **must** have `method="post"`.
2. The action function will automatically receive the form's data as a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object as its first parameter.
3. For SSR environments, you **must** provide a unique name as the second parameter to the `action` function.
   This name is used by Solid Router to uniquely identify and serialize the action across the client and server.

```tsx
import { action } from "@solidjs/router";

const addPostAction = action(async (formData: FormData) => {
	// ...
}, "addPost");

function AddPostForm() {
	return (
		<form action={addPostAction} method="post">
			<input id="title" name="title" placeholder="Enter post title" />
			<button type="submit">Create Post</button>
		</form>
	);
}
```

When the form is submitted, `addPostFormAction` will be invoked with the `FormData` containing the form values.

:::tip[Uploading files]
If your form includes file inputs, ensure your `<form>` element has `enctype="multipart/form-data"` to correctly send the file data.

```tsx
<form action={uploadFileAction} method="post" enctype="multipart/form-data">
	<input type="file" name="myFile" />
	<button type="submit">Upload</button>
</form>
```

:::

#### Passing additional arguments

Sometimes, your action needs data that isn't included in the form's inputs.
You can pass these additional arguments by using the `with` method.

The `with` method creates a new action that wraps around your original action.
When this new action is invoked, it passes the arguments specified in the `with` method to your original action function, followed by the `FormData` object.

```tsx
import { action } from "@solidjs/router";

const editPostAction = action(async (postId: string, formData: FormData) => {
	// ...
}, "editPost");

function EditPostForm(props: { postId: string }) {
	return (
		<form action={editPostAction.with(props.postId)} method="post">
			<input name="title" placeholder="New title" />
			<button type="submit">Edit Post</button>
		</form>
	);
}
```

In this example, `editPostAction` receives `postId` (passed via `with`), and then the `formData` from the form.

### With the `useAction` primitive

For scenarios where a `<form>` is not suitable, the `useAction` primitive provides a function to invoke an action programmatically.
This approach requires client-side JavaScript and is not progressively enhanceable.

The `useAction` primitive takes an action as its argument and returns a function that, when called, will invoke the action with the provided parameters.

```tsx
import { action, useAction } from "@solidjs/router";

const likePostAction = action(async (postId: string) => {
	await fetch(`https://api.com/posts/${encodeURIComponent(postId)}/likes`, {
		method: "POST",
	});
});

function LikePostButton(props: { postId: string }) {
	const likePost = useAction(likePostAction);

	return <button onClick={() => likePost(props.postId)}>Like</button>;
}
```

In this example, `likePost` is a function that can be called with arguments matching `likePostAction`.
When the button is clicked, `likePostAction` is invoked for the specific `postId`.

## Tracking submission state

When an action is invoked, it creates a **submission** object.
This object is a snapshot of the action's execution, containing its input, current status (pending or complete), and its final result or error.
To access this state, Solid Router provides the `useSubmission` and `useSubmissions` primitives.

The `useSubmission` primitive tracks the state of the _most recent_ submission for a specific action.
This is ideal for most use cases, such as disabling a form's submit button while the action is pending or displaying a confirmation message upon success.

```tsx
import { Show } from "solid-js";
import { action, useSubmission } from "@solidjs/router";

const saveSettingsAction = action(async (formData: FormData) => {
	const email = formData.get("email")?.toString();

	if (!email || !email.includes("@")) {
		return { ok: false, message: "Please enter a valid email address." };
	}

	// ...send data to server

	return { ok: true };
}, "save-settings");

function UserSettingsForm() {
	const submission = useSubmission(saveSettingsAction);

	return (
		<form action={saveSettingsAction} method="post">
			<input name="email" type="email" placeholder="Enter your email" />

			<button type="submit" disabled={submission.pending}>
				{submission.pending ? "Saving..." : "Save Settings"}
			</button>

			<Show
				when={submission.result?.ok}
				fallback={
					<div>
						<p>Error: {submission.result.message}</p>
						<button onClick={() => submission.clear()}>Clear Error</button>
						<button onClick={() => submission.retry()}>Retry</button>
					</div>
				}
			>
				<p>Settings saved successfully!</p>
			</Show>
		</form>
	);
}
```

In this example, the form's submit button is disabled while `submission.pending` is true, and messages are shown based on the `submission.error` or `submission.result` properties.
The `clear` method resets the submission state, and `retry` re-executes the last submission with its original input.

For more details, see the [`useSubmission` API reference](/solid-router/reference/data-apis/use-submission).

:::tip
If you need to track multiple concurrent submissions for a single action, such as in a multi-file uploader interface, you can use the [`useSubmissions` primitive](/solid-router/reference/data-apis/use-submissions).
:::

## Handling errors

Actions provide two primary mechanisms for error handling.

1. **Throwing an `Error`:**
   You can `throw` an `Error` instance within an action.
   When you do, Solid Router catches it and makes it available in the `submission.error` property.
2. **Returning a structured object:**
   For more complex scenarios, like form validation, you can `return` an object from your action.
   This object is then available in the `submission.result` property.
   This allows you to pass detailed error information back to your component for display.

While you can use either method as you see fit, a common pattern is to `throw` for unexpected errors and `return` an object for expected ones (like validation failures).

```tsx
import { action, useSubmission } from "@solidjs/router";
import { Show } from "solid-js";

const editPostAction = action(async (postId: string, formData: FormData) => {
	const title = formData.get("title")?.toString();

	// Validation errors are expected.
	// We return an object to handle them gracefully.
	if (!title || title.length < 3) {
		return {
			success: false,
			errors: { title: "Title must be at least 3 characters long." },
		};
	}

	const response = await fetch(`https://api.com/posts/${postId}`, {
		method: "PATCH",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({ title }),
	});

	if (!response.ok) {
		// Server-side validation errors are also expected.
		if (response.status === 400) {
			const errorData = await response.json();
			return {
				success: false,
				errors: errorData,
			};
		}

		// For other failures, we throw an error.
		throw new Error("An unexpected error occurred. Please try again.");
	}

	return { success: true };
}, "editPost");

function EditPostForm(props: { postId: string }) {
	const submission = useSubmission(editPostAction);
	const errors = () => submission.result?.errors;

	return (
		<form action={editPostAction.with(props.postId)} method="post">
			<Show when={submission.error}>
				{(error) => (
					<div>
						<p>{error().message}</p>
						<button type="button" onClick={() => submission.retry()}>
							Try Again
						</button>
					</div>
				)}
			</Show>

			<div>
				<input name="title" placeholder="Enter new title" />
				<Show when={errors()?.title}>{(error) => <p>{error()}</p>}</Show>
			</div>

			<button type="submit" disabled={submission.pending}>
				{submission.pending ? "Saving..." : "Save Changes"}
			</button>
		</form>
	);
}
```

In this example:

- If the title validation fails, the action returns an object with an `errors` field.
  The UI then accesses `submission.result.errors.title` to display the specific validation message.
- If an unexpected server error occurs, the action throws an `Error`.
  The UI uses `submission.error` to display a generic error message and provides a "Try Again" button.

## Automatic data revalidation

After you change data on the server, you face a common challenge: the data displayed in your UI is now stale.
To solve this, Solid Router automatically revalidates the data for the current route after a successful action.

This means you typically don't have to manually refetch data after a mutation.
Behind the scenes, Solid Router re-runs all active queries on the page, ensuring that any component using that data is automatically updated with the freshest information.

For example, if you have a page that displays a list of posts and includes a form to add a new one, the list will automatically update after you submit the form.

```tsx
import { query, action, createAsync } from "@solidjs/router";

const getPostsQuery = query(async () => {
	const response = await fetch("https://api.com/posts");
	return await response.json();
}, "getPosts");

const addPostAction = action(async (formData: FormData) => {
	const title = formData.get("title")?.toString();
	await fetch("https://api.com/posts", {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({ title }),
	});
}, "addPost");

function PostsPage() {
	// This query will automatically revalidate after addPostAction completes.
	const posts = createAsync(() => getPostsQuery());

	return (
		<div>
			<h2>All Posts</h2>
			<For each={posts()}>{(post) => <p>{post.title}</p>}</For>

			<h3>Add New Post</h3>
			<form action={addPostAction} method="post">
				<input name="title" placeholder="Post title" />
				<button type="submit">Add Post</button>
			</form>
		</div>
	);
}
```

While this automatic behavior is convenient for most cases, you may need more fine-grained control.
The next section on managing navigation and revalidation explains how you can customize or even disable this behavior for specific actions.

## Managing navigation and revalidation

While automatic revalidation is powerful, you often need more control.
You might want to redirect the user to a different page, prevent revalidation entirely, or revalidate a specific set of queries.
This is where response helpers come in.

Response helpers are functions that create special `Response` objects.
When an action returns or throws one of these responses, Solid Router intercepts it and performs a specific task.

### Redirecting

If you want to navigate the user to a new page after an action completes, you can use the [`redirect`](/solid-router/reference/response-helpers/redirect) helper.

```tsx
import { action, redirect } from "@solidjs/router";

const loginAction = action(async (formData: FormData) => {
	// ...login logic
	throw redirect("/dashboard");
});
```

### Customizing revalidation

To override the default revalidation behavior, you can use the [`reload`](/solid-router/reference/response-helpers/reload) and [`json`](/solid-router/reference/response-helpers/json) helpers.

- `reload`: Use this when you only need to control revalidation.
- `json`: Use this when you need to control revalidation _and_ return data from the action.

Both helpers accept a `revalidate` option, which takes an array of query keys to revalidate.
If you provide an empty array (`[]`), you can prevent revalidation altogether.

```tsx
import { action, reload, json } from "@solidjs/router";

// Example 1: Revalidating a specific query
const savePreferencesAction = action(async (formData: FormData) => {
	// ...save preferences logic

	// Only revalidate the 'userPreferences' query
	throw reload({ revalidate: ["userPreferences"] });
});

// Example 2: Disabling revalidation and returning data
const logActivityAction = action(async (activityData: FormData) => {
	// ...log activity to server

	// Return a success message without revalidating any queries
	return json({ success: true }, { revalidate: [] });
});
```

:::tip[Throwing vs. Returning]
You can either `return` or `throw` a response helper.
In TypeScript, `throw` can be more convenient, as it avoids potential type conflicts with your action's expected return value.
:::

## Optimistic UI

Optimistic UI is a pattern where you update the user interface immediately after a user performs an operation.
This is done without waiting for the server to confirm the operation's success.
This approach makes your application feel faster and more responsive.
If the operation fails, the UI change is reverted.

Actions can be combined with local state management to implement optimistic UI.
You can use the `useSubmission` primitive to access the input of an action as it's being submitted.
This input can be used to temporarily update your UI.

```tsx
import { For, createSignal, Show } from "solid-js";
import { query, action, createAsync, useSubmission } from "@solidjs/router";

const getPostsQuery = query(async () => {
	const response = await fetch("https://api.com/posts");
	return await response.json();
}, "getPosts");

const addPostAction = action(async (formData: FormData) => {
	const title = formData.get("title")?.toString();

	const response = await fetch("https://api.com/posts", {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({ title }),
	});

	if (!response.ok) {
		return { ok: false, message: "Failed to add post" };
	}

	return { ok: true };
}, "addPost");

function PostsPage() {
	const postsQuery = createAsync(() => getPostsQuery());
	const submission = useSubmission(addPostAction);

	const optimisticPosts = () => {
		const originalPosts = postsQuery() ?? [];
		if (submission.pending) {
			const formData = submission.input[0] as FormData;
			const title = formData.get("title")?.toString();
			if (title) {
				// Add the optimistic post to the list with a temporary ID.
				return [...originalPosts, { id: -1, title }];
			}
		}
		return originalPosts;
	};

	return (
		<div>
			<h2>All Posts</h2>
			{/* The list now uses optimisticPosts to render */}
			<For each={optimisticPosts()}>{(post) => <p>{post.title}</p>}</For>

			<h3>Add New Post</h3>
			<form action={addPostAction} method="post">
				<input name="title" placeholder="Post title" />
				<button type="submit" disabled={submission.pending}>
					{submission.pending ? "Adding..." : "Add Post"}
				</button>
			</form>

			<Show when={submission.error}>
				<p>Failed to add post. Please try again.</p>
			</Show>
		</div>
	);
}
```

In this example, we create a derived signal `optimisticPosts`.
When an action is pending, it checks the `submission.input` and adds the new post to the list with a temporary ID.
This makes the new post appear in the list instantly.

If the action fails, `submission.pending` becomes false, and `optimisticPosts` will revert to showing the original list from `postsQuery`.
The error message will also be displayed.

When the action succeeds, Solid Router automatically revalidates `getPostsQuery`.
This fetches the updated list of posts from the server, including the newly created post with its final ID.
The UI then seamlessly updates to reflect the correct state.

:::note
For more advanced optimistic UI patterns, consider using a library like [TanStack Query](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates).
It provides robust tools for managing server state, including complex optimistic updates.
:::
