---
title: "Actions"
---

Actions provide a powerful and flexible mechanism for handling data mutations and side effects.
They are designed to simplify your application's data flow, ensure a consistent user experience, and integrate seamlessly with Solid's reactivity.

Actions provide several key benefits:

- **Centralized Logic**: Encapsulate the logic for data modifications in a single, reusable function.
- **Integrated State Management**: Solid Router automatically tracks the execution state of an action (whether it's pending, successful, or has encountered an error), making it easy to build reactive UI feedback.
- **Automatic Data Revalidation**: By default, after an action successfully completes, Solid Router revalidates any queries on the same page.
  This ensures your UI reflects the latest data without manual intervention.
- **Progressive Enhancement**: When used with HTML forms, actions can enable forms to function even if JavaScript is not yet loaded, providing a robust and accessible user experience.

## Creating actions

At their core, actions are **asynchronous functions** that you define using the `action` function.
The [`action`](/solid-router/reference/data-apis/action) function takes your asynchronous function and returns an action object.

To define an action, import the `action` function from `@solidjs/router` and pass it your asynchronous logic:

```tsx
import { action } from "@solidjs/router";

const addPostAction = action(async (title: string) => {
	const response = await fetch("https://api.com/posts", {
		method: "POST",
		headers: {
			"Content-Type": "application/json",
		},
		body: JSON.stringify({ title }),
	});

	if (!response.ok) {
		const errorData = await response.json();
		throw new Error(errorData.message || "Failed to add post");
	}

	return await response.json();
});
```

In this example, `addPostAction` handles sending a POST request to create a new post.
The return value of the action can be accessed later when tracking action state.

:::note[Server-Side Rendering (SSR)]
When using actions with SSR, you must provide a unique name string as the second parameter to the `action` function.
This is crucial for Solid Router to correctly identify and re-run actions on the server.
We'll explore this in more detail in the Handling Form Submissions section.
:::

## How to Use Actions

Solid Router offers two primary ways to invoke an action:

1.  **Via the `<form>` element's `action` prop**: This is the recommended approach for most data mutations, especially those triggered by user input, as it provides **progressive enhancement**.
2.  **Programmatically with `useAction`**: For scenarios where you need to trigger an action outside of a form context.

### Handling Form Submissions with the `action` prop

Solid Router extends the standard HTML `<form>` element to accept an `action` prop, allowing you to handle your form submissions to an action.
This method provides the best user experience due to progressive enhancement.

When using actions with `<form>`:

1. The `<form>` element **must** have `method="post"`.
2. The action function will automatically receive the form's data as a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object as its first parameter.
3. For SSR environments, you **must** provide a unique name string as the second parameter to the `action` function.
   This name is used by Solid Router to uniquely identify and serialize the action across the client and server.

```tsx
import { action } from "@solidjs/router";

const addPostAction = action(async (formData: FormData) => {
	const title = formData.get("title")?.toString();

	if (!title || title.trim() === "") {
		throw new Error("Post title cannot be empty.");
	}

	const response = await fetch("https://api.com/posts", {
		method: "POST",
		headers: {
			"Content-Type": "application/json",
		},
		body: JSON.stringify({ title }),
	});

	if (!response.ok) {
		const errorData = await response.json();
		throw new Error(errorData.message || "Failed to add post");
	}
}, "add-post");

function AddPostForm() {
	return (
		<form action={addPostAction} method="post">
			<label for="title">Post Title:</label>
			<input id="title" name="title" placeholder="Enter post title" />
			<button type="submit">Create Post</button>
		</form>
	);
}
```

When this form is submitted, `addPostFormAction` will be invoked with the `FormData` containing the form values.

:::tip[File Uploads]

If your form includes file inputs, ensure your <form> element has enctype="multipart/form-data" to correctly send the file data.

```tsx
<form action={uploadFileAction} method="post" enctype="multipart/form-data">
	<input type="file" name="myFile" />
	<button type="submit">Upload</button>
</form>
```

:::

#### Passing additional data

Sometimes, your action might need additional data that isn't part of the form's inputs.
You can pass these additional arguments using the `with` method on your action.

Arguments passed to `with` will be forwarded to your action function before the `FormData` object.

```tsx
import { action } from "@solidjs/router";

const updatePostAction = action(async (postId: string, formData: FormData) => {
	const newTitle = formData.get("title")?.toString();

	if (!newTitle || newTitle.trim() === "") {
		throw new Error("Post title cannot be empty.");
	}

	const response = await fetch(
		`https://api.com/posts/${encodeURIComponent(newTitle)}`,
		{
			method: "PUT",
			headers: {
				"Content-Type": "application/json",
			},
			body: JSON.stringify({ title: newTitle }),
		}
	);

	if (!response.ok) {
		const errorData = await response.json();
		throw new Error(errorData.message || "Failed to update post");
	}
});

function PostEditForm(props: { postId: string }) {
	return (
		<form action={updatePostAction.with(props.postId)} method="post">
			<label for="title">Title:</label>
			<input id="title" name="title" placeholder="New title" />
			<button type="submit">Update Post</button>
		</form>
	);
}
```

Here, `updatePostAction` receives `postId` (passed via `with`), and then the `formData` from the form.
