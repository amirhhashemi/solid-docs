---
title: "Actions"
---

In web applications, many user interactions result in changing data on the server.
These changes, often called mutations, require careful management of asynchronous operations, state updates, and error handling.
Actions provide a comprehensive framework for managing these data mutations.
They are designed to handle everything from simple form submissions to complex asynchronous workflows.

Actions provide several benefits:

- **Integrated state management:**
  Solid Router automatically tracks the execution state of an action, simplifying reactive UI feedback.
- **Automatic data revalidation:**
  After an action successfully completes, Solid Router revalidates relevant queries, ensuring the UI reflects the latest data.
- **Progressive enhancement:**
  When used with HTML forms, actions enable functionality even if JavaScript is not yet loaded.

## Defining actions

At their core, actions are asynchronous operations.
They are defined by wrapping asynchronous logic with the [`action`](/solid-router/reference/data-apis/action) function.
When the action is invoked, Solid Router executes the defined logic.

```tsx
import { action } from "@solidjs/router";

const addPostAction = action(async (title: string) => {
	const response = await fetch("https://api.com/posts", {
		method: "POST",
		headers: {
			"Content-Type": "application/json",
		},
		body: JSON.stringify({ title }),
	});

	if (!response.ok) {
		const errorData = await response.json();
		return { ok: false, message: errorData.message };
	}

	return { ok: true };
});
```

In this example, an action is defined that sends a POST request to create a new post.

## Invoking actions

Actions can be invoked in two primary ways: through an HTML `<form>` or programmatically with the `useAction` primitive.

The recommended approach for is to use a `<form>`.
This ensures the application works even before any client-side JavaScript has loaded, providing a robust user experience through progressive enhancement.

For cases where a form is not suitable, the [`useAction` primitive](/solid-router/reference/data-apis/use-action) can be used to invoke the action programmatically.

### With the `<form>` element

Solid Router extends the standard HTML `<form>` element to work with actions.
By passing an action to the `action` prop, form submissions can be handled seamlessly.

Consider these points when using actions with `<form>`:

1. The `<form>` element **must** have `method="post"`.
2. The action function will automatically receive the form's data as a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object as its first parameter.
3. For SSR environments, a unique name **must** be provided as the second parameter to the `action` function.
   This name is used by Solid Router to uniquely identify and serialize the action across the client and server.

```tsx
import { action } from "@solidjs/router";

const addPostAction = action(async (formData: FormData) => {
	// ... Handles the form submission logic.
}, "addPost");

function AddPostForm() {
	return (
		<form action={addPostAction} method="post">
			<input name="title" placeholder="Enter post title" />
			<button type="submit">Create Post</button>
		</form>
	);
}
```

In this example, when the form is submitted, `addPostAction` will be invoked with the `FormData` containing the form values.

:::tip[Uploading files]
If a form includes file inputs, the `<form>` element must have `enctype="multipart/form-data"` to correctly send the file data.

```tsx
<form action={uploadFileAction} method="post" enctype="multipart/form-data">
	<input type="file" name="myFile" />
	<button type="submit">Upload</button>
</form>
```

:::

#### Passing additional arguments

Sometimes, an action needs data that isn't included in the form's inputs.
These additional arguments can be passed by using the `with` method.

The `with` method creates a new action that wraps around the original action.
When this new action is invoked, it passes the arguments specified in the `with` method to the original action function, followed by the `FormData` object.

```tsx
import { action } from "@solidjs/router";

const editPostAction = action(async (postId: string, formData: FormData) => {
	// ... Handles the edit logic.
}, "editPost");

function EditPostForm(props: { postId: string }) {
	return (
		<form action={editPostAction.with(props.postId)} method="post">
			<input name="title" placeholder="New title" />
			<button type="submit">Edit Post</button>
		</form>
	);
}
```

In this example, `editPostAction` receives `postId` (passed via `with`), and then the `formData` from the form.

### With the `useAction` primitive

For scenarios where a `<form>` is not suitable, the `useAction` primitive provides a function to invoke an action programmatically.
This approach requires client-side JavaScript and is not progressively enhanceable.

The `useAction` primitive takes an action as its argument and returns a function that, when called, will invoke the action with the provided parameters.

```tsx
import { action, useAction } from "@solidjs/router";

const likePostAction = action(async (postId: string) => {
	// ... Likes a post on the server.
});

function LikePostButton(props: { postId: string }) {
	const likePost = useAction(likePostAction);

	return <button onClick={() => likePost(props.postId)}>Like</button>;
}
```

In this example, `likePost` is a function that can be called with arguments matching `likePostAction`.
When the button is clicked, `likePostAction` is invoked for the specific `postId`.

## Tracking submission state

When an action is invoked, it creates a **submission** object.
This object is a snapshot of the action's execution, containing its input, current status (pending or complete), and its final result or error.
To access this state, Solid Router provides the `useSubmission` and `useSubmissions` primitives.

The [`useSubmission` primitive](/solid-router/reference/data-apis/use-submission) tracks the state of the _most recent_ submission for a specific action.
This is ideal for most use cases, such as disabling a form's submit button while the action is pending or displaying a confirmation message upon success.

```tsx
import { Show } from "solid-js";
import { action, useSubmission } from "@solidjs/router";

const saveSettingsAction = action(async (formData: FormData) => {
	const email = formData.get("email")?.toString();

	if (!email || !email.includes("@")) {
		return { ok: false, message: "Please enter a valid email address." };
	}

	// ... Sends the settings data to the server.

	return { ok: true };
}, "save-settings");

function UserSettingsForm() {
	const submission = useSubmission(saveSettingsAction);

	return (
		<form action={saveSettingsAction} method="post">
			<input name="email" type="email" placeholder="Enter your email" />

			<button type="submit" disabled={submission.pending}>
				{submission.pending ? "Saving..." : "Save Settings"}
			</button>

			<Show when={!submission.result?.ok}>
				<p>Error: {submission.result.message}</p>
			</Show>
		</form>
	);
}
```

In this example, the form's submit button is disabled while `submission.pending` is true.
Error messages are shown based on the `submission.result` property.

For more details, see the [`useSubmission` API reference](/solid-router/reference/data-apis/use-submission).

:::tip
To track multiple submissions for a single action, such as in a multi-file uploader interface, use the [`useSubmissions` primitive](/solid-router/reference/data-apis/use-submissions).
:::

## Handling errors

When an action performs an operation like an API call, it can fail for various reasons.
A robust application must handle these failures gracefully.
Solid Router provides two mechanisms for an action to signal its outcome: returning a value or throwing an `Error`.

Throwing an `Error` is a valid way to signal failure.
Solid Router will catch the thrown error and make it available in the `submission.error` property.
However, this approach has some drawbacks.
The `submission.error` property is typed as `any`, which undermines type safety in the consuming component.
It is also difficult to convey structured error information, such as validation messages for multiple form fields, using a simple `Error` instance.

For these reasons, the recommended practice is to always `return` a descriptive object from an action to represent its outcome.
The returned object is available in the `submission.result` property, which will be fully typed.
This makes handling different outcomes in the UI simple and safe.

```tsx
import { Show } from "solid-js";
import { action, useSubmission } from "@solidjs/router";

const editPostAction = action(async (formData: FormData) => {
	const title = formData.get("title")?.toString();

	if (!title || title.length < 3) {
		return {
			ok: false,
			errors: { title: "Title must be at least 3 characters long." },
		};
	}

	// ... Performs an update on the server and handles potential errors.

	return { ok: true };
}, "editPost");

function EditPostForm(props: { postId: string }) {
	const submission = useSubmission(editPostAction);

	const errors = () => {
		const result = submission.result;
		if (result && !result.ok) {
			return result.errors;
		}
	};

	return (
		<form action={editPostAction.with(props.postId)} method="post">
			<Show when={errors()?.server}>
				<p>{errors().server}</p>
			</Show>

			<div>
				<input name="title" placeholder="Enter new title" />
				<Show when={errors()?.title}>
					<p>{errors().title}</p>
				</Show>
			</div>

			<button type="submit" disabled={submission.pending}>
				{submission.pending ? "Saving..." : "Save Changes"}
			</button>
		</form>
	);
}
```

In this example, the `errors` derived signal inspects `submission.result` to check for failures.
If an error object is found, its properties are used to conditionally render error messages next to the relevant form fields.

:::caution[Always return a value]
It is important that an action consistently returns a value from all of its possible code paths.
If an action returns `undefined` or `null`, Solid Router removes that submission from its internal list upon completion.
This can lead to unexpected behavior.
For example, consider an action that returns an error object on failure but returns nothing on success.
If the action fails once, `useSubmission` will correctly report the error.
However, if a subsequent submission succeeds, it will be removed from the list, and `useSubmission` will continue to report the previous stale error state.
To prevent this, ensure every code path in an action returns a value, such as `{ ok: true }` for a successful outcome.
:::

## Automatic data revalidation

After changing data on the server, the data displayed in the UI can become stale.
To solve this, Solid Router automatically revalidates the data for the current route after a successful action.

This means data does not have to be manually refetched after a mutation.
Behind the scenes, Solid Router re-runs all active queries on the page, ensuring that any component using that data is automatically updated with the freshest information.

For example, if a page displays a list of posts and includes a form to add a new one, the list will automatically update after the form is submitted.

```tsx
import { For } from "solid-js";
import { query, action, createAsync } from "@solidjs/router";

const getPostsQuery = query(async () => {
	// ... Fetches the list of posts.
}, "getPosts");

const addPostAction = action(async (formData: FormData) => {
	// ... Adds a new post.
}, "addPost");

function PostsPage() {
	// This query will automatically revalidate after addPostAction completes.
	const posts = createAsync(() => getPostsQuery());

	return (
		<div>
			<h2>All Posts</h2>
			<For each={posts()}>{(post) => <p>{post.title}</p>}</For>

			<h3>Add New Post</h3>
			<form action={addPostAction} method="post">
				<input name="title" placeholder="Post title" />
				<button type="submit">Add Post</button>
			</form>
		</div>
	);
}
```

While this automatic behavior is convenient for most cases, more fine-grained control may be needed.
The next section explains how to customize or even disable this behavior for specific actions.

## Managing navigation and revalidation

While automatic revalidation is powerful, more control is often needed.
It may be desirable to redirect the user to a different page, prevent revalidation entirely, or revalidate a specific set of queries.
This is where response helpers come in.

Response helpers are functions that create special `Response` objects.
When an action returns or throws one of these responses, Solid Router intercepts it and performs a specific task.

### Redirecting

To navigate the user to a new page after an action completes, the [`redirect`](/solid-router/reference/response-helpers/redirect) helper can be used.
It can also be used to revalidate specific queries upon redirection, which is useful for updating data that is displayed on the new page.

```tsx
import { action, redirect } from "@solidjs/router";

const loginAction = action(async (formData: FormData) => {
	// ... Handles the login logic.

	// Redirect to the dashboard and revalidate the session query.
	throw redirect("/dashboard", { revalidate: ["session"] });
});
```

In this example, after a successful login, the `redirect` helper is used to navigate to the dashboard.
It also revalidates the "session" query to ensure the UI reflects the user's authenticated state.

### Customizing revalidation

To override the default revalidation behavior, the [`reload`](/solid-router/reference/response-helpers/reload) and [`json`](/solid-router/reference/response-helpers/json) helpers can be used.

- `reload`: Use this when only revalidation needs to be controlled.
- `json`: Use this when revalidation needs to be controlled _and_ data needs to be returned from the action.

Both helpers accept a `revalidate` option, which takes an array of query keys to revalidate.
If an empty array (`[]`) is provided, revalidation can be prevented altogether.

```tsx
import { action, reload, json } from "@solidjs/router";

// Example 1: Revalidating a specific query
const savePreferencesAction = action(async (formData: FormData) => {
	// ... Saves the user preferences.

	// Only revalidate the 'userPreferences' query
	throw reload({ revalidate: ["userPreferences"] });
});

// Example 2: Disabling revalidation and returning data
const logActivityAction = action(async (activityData: FormData) => {
	// ... Logs the activity to the server.

	// Return without revalidating any queries
	return json({ ok: true }, { revalidate: [] });
});
```

:::tip[Throwing vs. Returning]
A response helper can be either `return`ed or `throw`n.
In TypeScript, `throw` can be more convenient, as it avoids potential type conflicts with an action's expected return value.
:::

## Optimistic UI

Optimistic UI is a pattern where the user interface is updated immediately after a user performs an operation.
This is done without waiting for the server to confirm the operation's success.
This approach makes an application feel faster and more responsive.
If the operation fails, the UI change is reverted.

Actions can be combined with local state management to implement optimistic UI.
The `useSubmission` primitive can be used to access the input of an action as it's being submitted.
This input can be used to temporarily update the UI.

```tsx
import { For, createSignal, Show } from "solid-js";
import { query, action, createAsync, useSubmission } from "@solidjs/router";

const getPostsQuery = query(async () => {
	// ... Fetches the list of posts.
}, "getPosts");

const addPostAction = action(async (formData: FormData) => {
	// ... Adds a new post and handles potential errors.
}, "addPost");

function PostsPage() {
	const postsQuery = createAsync(() => getPostsQuery());
	const submission = useSubmission(addPostAction);

	const optimisticPosts = () => {
		const originalPosts = postsQuery() ?? [];
		if (submission.pending) {
			const formData = submission.input[0] as FormData;
			const title = formData.get("title")?.toString();
			if (title) {
				// Add the optimistic post to the list with a temporary ID.
				return [...originalPosts, { id: -1, title }];
			}
		}
		return originalPosts;
	};

	return (
		<div>
			<h2>All Posts</h2>
			{/* The list now uses optimisticPosts to render */}
			<For each={optimisticPosts()}>{(post) => <p>{post.title}</p>}</For>

			<h3>Add New Post</h3>
			<form action={addPostAction} method="post">
				<input name="title" placeholder="Post title" />
				<button type="submit" disabled={submission.pending}>
					{submission.pending ? "Adding..." : "Add Post"}
				</button>
			</form>
		</div>
	);
}
```

In this example, a derived signal `optimisticPosts` is created.
When an action is pending, it checks the `submission.input` and adds the new post to the list with a temporary ID.
This makes the new post appear in the list instantly.

If the action fails, `submission.pending` becomes false, and `optimisticPosts` will revert to showing the original list from `postsQuery`.
The error message will also be displayed.

When the action succeeds, Solid Router automatically revalidates `getPostsQuery`.
This fetches the updated list of posts from the server, including the newly created post with its final ID.
The UI then seamlessly updates to reflect the correct state.

:::note
For more advanced optimistic UI patterns, consider using a library like [TanStack Query](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates).
It provides robust tools for managing server state, including complex optimistic updates.
:::