---
title: "Actions"
---

Many user interactions in an application involve changing data on the server.
These **mutations** can be challenging to manage, as they require updates to the application's state and proper error handling.
Actions provide a simple solution for managing these data mutations.

Actions provide several benefits:

- **Integrated state management:**
  Solid Router automatically tracks the execution state of an action, simplifying reactive UI feedback.
- **Automatic data revalidation:**
  After an action successfully completes, Solid Router revalidates relevant [`queries`](/solid-router/concepts/queries), ensuring the UI reflects the latest data.
- **Progressive enhancement:**
  When used with HTML forms, actions enable functionality even if JavaScript is not yet loaded.

## Defining actions

At their core, actions are asynchronous operations.
They are defined by wrapping asynchronous logic with the [`action`](/solid-router/reference/data-apis/action) function.
When the action is invoked, Solid Router executes the defined logic.

```tsx
import { action } from "@solidjs/router";

const createTicketAction = action(async (subject: string) => {
	const response = await fetch("https://api.com/support/tickets", {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({ subject }),
	});

	if (!response.ok) {
		const errorData = await response.json();
		return { ok: false, message: errorData.message };
	}

	return { ok: true };
}, "createTicket");
```

In this example, an action is defined that creates a support ticket with a subject.

## Invoking actions

Actions can be invoked in two primary ways: through an HTML `<form>` or programmatically with the `useAction` primitive.

The recommended approach is to use a `<form>`.
This ensures the application works even before any client-side JavaScript has loaded, providing a robust user experience through progressive enhancement.

For cases where a form is not suitable, the [`useAction` primitive](/solid-router/reference/data-apis/use-action) can be used to invoke the action programmatically.

### With the `<form>` element

Solid Router extends the standard HTML `<form>` element to work with actions.
By passing an action to the `action` prop, form submissions can be handled seamlessly.

Consider these points when using actions with `<form>`:

1. The `<form>` element **must** have `method="post"`.
2. The action function will automatically receive the form's data as a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object as its first parameter.
3. For SSR environments, a unique name **must** be provided as the second parameter to the `action` function.
   This name is used by Solid Router to uniquely identify and serialize the action across the client and server.

```tsx
import { action } from "@solidjs/router";

const submitFeedbackAction = action(async (formData: FormData) => {
	const message = formData.get("message")?.toString();

	// ... Sends the feedback to the server.

	return { ok: true };
}, "submitFeedback");

function FeedbackForm() {
	return (
		<form action={submitFeedbackAction} method="post">
			<textarea name="message" placeholder="Message" />
			<button type="submit">Send feedback</button>
		</form>
	);
}
```

In this example, when the form is submitted, `submitFeedbackAction` will be invoked with the `FormData` containing the form values.

:::tip[Uploading files]
If a form includes file inputs, the `<form>` element must have `enctype="multipart/form-data"` to correctly send the file data.

```tsx
<form action={uploadFileAction} method="post" enctype="multipart/form-data">
	<input type="file" name="myFile" />
	<button type="submit">Upload</button>
</form>
```

:::

#### Passing additional arguments

Sometimes, an action needs data that isn't included in the form's inputs.
These additional arguments can be passed by using the `with` method.

The `with` method creates a new action that wraps around the original action.
When this new action is invoked, it passes the arguments specified in the `with` method to the original action function, followed by the `FormData` object.

```tsx
import { action } from "@solidjs/router";

const updateProductAction = action(
	async (productId: string, formData: FormData) => {
		// ... Sends the updated fields to the server.

		return { ok: true };
	},
	"updateProduct"
);

function EditProductForm(props: { productId: string }) {
	return (
		<form action={updateProductAction.with(props.productId)} method="post">
			<input name="name" placeholder="Product name" />
			<input name="price" type="number" step="0.01" placeholder="Price" />
			<button type="submit">Save product</button>
		</form>
	);
}
```

In this example, `updateProductAction` receives `productId` (passed via `with`), and then the `formData` from the form.

### With the `useAction` primitive

For scenarios where a `<form>` is not suitable, the `useAction` primitive provides a function to invoke an action programmatically.
This approach requires client-side JavaScript and is not progressively enhanceable.

The `useAction` primitive takes an action as its argument and returns a function that, when called, will invoke the action with the provided parameters.

```tsx
import { action, useAction } from "@solidjs/router";

const markNotificationReadAction = action(async (notificationId: string) => {
	// ... Marks a notification as read on the server.
});

function NotificationItem(props: { id: string }) {
	const markRead = useAction(markNotificationReadAction);

	return <button onClick={() => markRead(props.id)}>Mark as read</button>;
}
```

In this example, `markRead` is a function that can be called with arguments matching `markNotificationReadAction`.
When the button is clicked, the action is invoked for the specific notification.

## Tracking submission state

When an action is invoked, it creates a **submission** object.
This object is a snapshot of the action's execution, containing its input, current status (pending or complete), and its final result or error.
To access this state, Solid Router provides the `useSubmission` and `useSubmissions` primitives.

The [`useSubmission` primitive](/solid-router/reference/data-apis/use-submission) tracks the state of the _most recent_ submission for a specific action.
This is ideal for most use cases, such as disabling a form's submit button while the action is pending or displaying a confirmation message upon success.

```tsx
import { Show } from "solid-js";
import { action, useSubmission } from "@solidjs/router";

const saveSettingsAction = action(async (formData: FormData) => {
	const email = formData.get("email")?.toString();

	if (!email || !email.includes("@")) {
		return { ok: false, message: "Please enter a valid email address." };
	}

	// ... Sends the settings data to the server.

	return { ok: true };
}, "saveSettings");

function UserSettingsForm() {
	const submission = useSubmission(saveSettingsAction);

	return (
		<form action={saveSettingsAction} method="post">
			<input name="email" type="email" placeholder="Enter your email" />

			<button type="submit" disabled={submission.pending}>
				{submission.pending ? "Saving..." : "Save settings"}
			</button>

			<Show when={!submission.result?.ok}>
				<p>Error: {submission.result.message}</p>
			</Show>
		</form>
	);
}
```

In this example, the form's submit button is disabled while `submission.pending` is true.
Error messages are shown based on the `submission.result` property.

For more details, see the [`useSubmission` API reference](/solid-router/reference/data-apis/use-submission).

:::tip
To track multiple submissions for a single action, such as in a multi-file uploader interface, use the [`useSubmissions` primitive](/solid-router/reference/data-apis/use-submissions).
:::

## Handling errors

When an action performs an operation like an API call, it can fail for various reasons.
A robust application must handle these failures gracefully.
Solid Router provides two mechanisms for an action to signal its outcome: returning a value or throwing an `Error`.

Throwing an `Error` is a valid way to signal failure.
Solid Router will catch the thrown error and make it available in the `submission.error` property.
However, this approach has some drawbacks.
The `submission.error` property is typed as `any`, which undermines type safety in the consuming component.
It is also difficult to convey structured error information, such as validation messages for multiple form fields, using a simple `Error` instance.

For these reasons, the recommended practice is to always `return` a descriptive object from an action to represent its outcome.
The returned object is available in the `submission.result` property, which will be fully typed.
This makes handling different outcomes in the UI simple and safe.

```tsx
import { Show } from "solid-js";
import { action, useSubmission } from "@solidjs/router";

const verifyTwoFactorAction = action(async (formData: FormData) => {
	const code = formData.get("code")?.toString();

	if (!code || code.length !== 6) {
		return {
			ok: false,
			errors: { code: "Enter the 6-digit code from the authenticator app." },
		};
	}

	// ... Verifies the code with the server and handles potential errors.

	return { ok: true };
}, "verifyTwoFactor");

function TwoFactorForm() {
	const submission = useSubmission(verifyTwoFactorAction);

	const errors = () => {
		const result = submission.result;
		if (result && !result.ok) {
			return result.errors;
		}
	};

	return (
		<form action={verifyTwoFactorAction} method="post">
			<div>
                <input name="code" placeholder="6-digit code" inputMode="numeric" />
				<Show when={errors()?.code}>
					<p>{errors().code}</p>
				</Show>
			</div>

			<button type="submit" disabled={submission.pending}>
				{submission.pending ? "Verifying..." : "Verify"}
			</button>
		</form>
	);
}
```

In this example, the `errors` derived signal inspects `submission.result` to check for failures.
If an error object is found, its properties are used to conditionally render error messages next to the relevant form fields.

:::caution[Always return a value]
It is important that an action consistently returns a value from all of its possible code paths.
If an action returns `undefined` or `null`, Solid Router removes that submission from its internal list upon completion.
This can lead to unexpected behavior.

For example, consider an action that returns an error object on failure but returns nothing on success.
If the action fails once, `useSubmission` will correctly report the error.
However, if a subsequent submission succeeds, it will be removed from the list, and `useSubmission` will continue to report the previous stale error state.
To prevent this, ensure every code path in an action returns a value, such as `{ ok: true }` for a successful outcome.
:::

## Automatic data revalidation

After changing data on the server, the data displayed in the UI can become stale.
To solve this, Solid Router automatically revalidates the data for the current route after a successful action.

This means data does not have to be manually refetched after a mutation.
Behind the scenes, Solid Router re-runs all active queries on the page, ensuring that any component using that data is automatically updated with the freshest information.

For example, if a page displays a list of registered devices and includes a form to register a new one, the list will automatically update after the form is submitted.

```tsx
import { For } from "solid-js";
import { query, action, createAsync } from "@solidjs/router";

const getDevicesQuery = query(async () => {
	// ... Fetches the list of registered devices.
}, "devices");

const registerDeviceAction = action(async (formData: FormData) => {
	// ... Registers a new device on the server.
}, "registerDevice");

function DevicesPage() {
	// This query will automatically revalidate after registerDeviceAction completes.
	const devices = createAsync(() => getDevicesQuery());

	return (
		<div>
			<h2>Registered devices</h2>
			<For each={devices()}>{(device) => <p>{device.name}</p>}</For>

			<h3>Register new device</h3>
			<form action={registerDeviceAction} method="post">
				<input name="name" placeholder="Device name" />
				<button type="submit">Register device</button>
			</form>
		</div>
	);
}
```

While this automatic behavior is convenient for most cases, more fine-grained control may be needed.
The next section explains how to customize or even disable this behavior for specific actions.

## Managing navigation and revalidation

While automatic revalidation is powerful, more control is often needed.
It may be desirable to redirect the user to a different page, prevent revalidation entirely, or revalidate a specific set of queries.
This is where response helpers come in.

Response helpers are functions that create special `Response` objects.
When an action returns or throws one of these responses, Solid Router intercepts it and performs a specific task.

### Redirecting

To navigate the user to a new page after an action completes, the [`redirect`](/solid-router/reference/response-helpers/redirect) helper can be used.
It can also be used to revalidate specific queries upon redirection, which is useful for updating data that is displayed on the new page.

```tsx
import { action, redirect } from "@solidjs/router";

const loginAction = action(async (formData: FormData) => {
	// ... Handles the login logic.

	// Redirect to the dashboard and revalidate the session query.
	throw redirect("/dashboard", { revalidate: ["session"] });
});
```

In this example, after a successful login, the `redirect` helper is used to navigate to the dashboard.
It also revalidates the "session" query to ensure the UI reflects the user's authenticated state.

### Customizing revalidation

To override the default revalidation behavior, the [`reload`](/solid-router/reference/response-helpers/reload) and [`json`](/solid-router/reference/response-helpers/json) helpers can be used.

- `reload`: Use this when only revalidation needs to be controlled.
- `json`: Use this when revalidation needs to be controlled _and_ data needs to be returned from the action.

Both helpers accept a `revalidate` option, which takes an array of query keys to revalidate.
If an empty array (`[]`) is provided, revalidation can be prevented altogether.

```tsx
import { action, reload, json } from "@solidjs/router";

// Example 1: Revalidating a specific query
const savePreferencesAction = action(async (formData: FormData) => {
	// ... Saves the user preferences.

	// Only revalidate the 'userPreferences' query
	throw reload({ revalidate: ["userPreferences"] });
});

// Example 2: Disabling revalidation and returning data
const logActivityAction = action(async (activityData: FormData) => {
	// ... Logs the activity to the server.

	// Return without revalidating any queries
	return json({ ok: true }, { revalidate: [] });
});
```

:::tip[Throwing vs. Returning]
A response helper can be either `return`ed or `throw`n.
In TypeScript, `throw` can be more convenient, as it avoids potential type conflicts with an action's expected return value.
:::

## Optimistic UI

Optimistic UI is a pattern where the user interface is updated immediately after a user performs an operation.
This is done without waiting for the server to confirm the operation's success.
This approach makes an application feel faster and more responsive.
If the operation fails, the UI change is reverted.

Actions can be combined with local state management to implement optimistic UI.
The `useSubmission` primitive can be used to access the input of an action as it's being submitted.
This input can be used to temporarily update the UI.

```tsx
import { For, Show } from "solid-js";
import { query, action, createAsync, useSubmission } from "@solidjs/router";

const getCartQuery = query(async () => {
	// ... Fetches the current shopping cart items.
}, "cart");

const addToCartAction = action(async (formData: FormData) => {
	// ... Adds a product to the cart and handles potential errors.
}, "addToCart");

function CartPage() {
	const cart = createAsync(() => getCartQuery());
	const submission = useSubmission(addToCartAction);

	const optimisticCart = () => {
		const originalItems = cart() ?? [];
		if (submission.pending) {
			const formData = submission.input[0] as FormData;
			const productId = formData.get("productId")?.toString();
			const name = formData.get("name")?.toString();
			if (productId && name) {
				// Add the optimistic line item with a temporary identifier.
				return [...originalItems, { id: "temp", productId, name, quantity: 1 }];
			}
		}
		return originalItems;
	};

	return (
		<div>
			<h2>Your cart</h2>
			<For each={optimisticCart()}>{(item) => <p>{item.name}</p>}</For>

			<h3>Add item</h3>
			<form action={addToCartAction} method="post">
				<input name="productId" placeholder="Product ID" />
				<input name="name" placeholder="Product name" />
				<button type="submit" disabled={submission.pending}>
					{submission.pending ? "Adding..." : "Add to cart"}
				</button>
			</form>
		</div>
	);
}
```

In this example, a derived signal `optimisticCart` is created.
When an action is pending, it checks the `submission.input` and adds the new line item to the list with a temporary identifier.
If the action fails, `submission.pending` becomes false, and `optimisticCart` will revert to showing the original list from `cart`.
When the action succeeds, Solid Router automatically revalidates `getCartQuery` and updates the UI with the confirmed cart state.

:::note
For more advanced optimistic UI patterns, consider using a library like [TanStack Query](https://tanstack.com/query/latest/docs/framework/solid/guides/optimistic-updates).
It provides robust tools for managing server state, including complex optimistic updates.
:::
