---
title: "Queries"
---

Fetching data from a server or other data source is a key part of most applications.
Doing this properly requires handling loading states, error states, and keeping the data up to date, which can be complex.
Queries provide an elegant solution for managing these tasks.

## Defining a query

Queries are defined using the [`query`](/solid-router/reference/data-apis/query) function, which takes two parameters:

1. Fetcher is an asynchronous function that fetches data from any source, such as a remote API.
2. Name is a string used to identify a query.
   When a query is invoked, Solid Router internally creates a key that consists of the query name and the arguments passed to the query.
   This key is used for deduplication.

The `query` function returns a new function, which we now refer to as a query.
This query has the same call signature as the fetcher, and it handles the deduplication, which is the foundation of how queries work.

```tsx
import { query } from "@solidjs/router";

const getUserProfileQuery = query(async (userId: string) => {
	const response = await fetch(
		`https://api.example.com/users/${encodeURIComponent(userId)}`
	);
	const json = await response.json();

	if (!response.ok) {
		throw new Error(json?.message ?? "Failed to load user profile.");
	}

	return json;
}, "userProfile");
```

In this example, a query is defined that fetches a user's profile from an API.
If it fails, it throws an error that can be handled by components.

## Using queries in components

Defining a query does not, by itself, fetch any data.
To call a query and make its data available to a component, the [`createAsync` primitive](/solid-router/reference/data-apis/create-async) is used.

`createAsync` takes a reactive function that returns a `Promise`.
It returns a signal that tracks the result of the `Promise`.

```tsx
import { For, Show } from "solid-js";
import { createAsync, query } from "@solidjs/router";

const getFeaturedArticlesQuery = query(async () => {
	// ... Fetches a list of featured articles.
}, "featuredArticles");

function FeaturedArticles() {
	const articles = createAsync(() => getFeaturedArticlesQuery());

	return (
		<Show when={articles()}>
			<For each={articles()}>{(article) => <p>{article.title}</p>}</For>
		</Show>
	);
}
```

## Handling loading and error states

The `createAsync` primitive is designed to work with Solid's native components for handling asynchronous states.
It communicates its pending state to a [`<Suspense>`](/reference/components/suspense) boundary for showing pending fallbacks.
It also propagates errors to an [`<ErrorBoundary>`](/reference/components/error-boundary) for displaying error messages.

By accessing a query's data within these two components, it is possible to handle both loading and error states gracefully.

```tsx
import { Suspense, ErrorBoundary, For } from "solid-js";
import { createAsync, query } from "@solidjs/router";

const getNewsQuery = query(async () => {
	// ... Fetches the latest news headlines.
}, "news");

function NewsFeed() {
	const news = createAsync(() => getNewsQuery());

	return (
		<ErrorBoundary fallback={<p>Could not fetch news.</p>}>
			<Suspense fallback={<p>Loading news...</p>}>
				<ul>
					<For each={news()}>{(item) => <li>{item.headline}</li>}</For>
				</ul>
			</Suspense>
		</ErrorBoundary>
	);
}
```

## Preloading data

Preloading data is a powerful technique to make an application feel faster.
Solid Router initiates preloading in two scenarios: when a user indicates an intent to navigate (for example, by hovering over a link), and before a route's component is rendered.
This ensures that data fetching begins at the earliest possible moment, often allowing data to be ready when the component renders.

Preloading is configured using the `preload` prop on a [`Route`](/solid-router/reference/components/route).
This prop accepts a function that calls one or more queries.
When triggered, the preload function executes the queries, and their results are stored in a short-lived internal cache.
When the user completes the navigation, the `createAsync` call in the component will find the preloaded data.
Because of the deduplication mechanism, it will use the existing data instead of sending a redundant network request.

```tsx
import { Route, query, createAsync } from "@solidjs/router";
import { Show } from "solid-js";

const getProductDetailsQuery = query(async (id: string) => {
	// ... Fetches product details for the given ID.
}, "productDetails");

function ProductDetails(props) {
	const product = createAsync(() => getProductDetailsQuery(props.params.id));

	return <Show when={product()}>{(p) => <h1>{p.name}</h1>}</Show>;
}

function preloadProduct({ params }: { params: { id: string } }) {
	getProductDetailsQuery(params.id);
}

function Routes() {
	return (
		<Route
			path="/products/:id"
			component={ProductDetails}
			preload={preloadProduct}
		/>
	);
}
```

In this example, hovering a link to `/products/:id` triggers `preloadProduct`.
When the `ProductDetails` component renders, its `createAsync` call will instantly resolve with the preloaded data.

## Deduplication

A key feature of queries is their ability to deduplicate requests.
This is different from a long-term caching strategy.
Instead, it is a short-term mechanism to prevent redundant data fetching in quick succession.

A common example of this is preloading.
When a user hovers over a link, the application can begin [preloading](/solid-router/reference/preload-functions/preload) the data for the destination page.
If the user then clicks the link, the query has already been executed, and the data is available instantly without a second network request.
This deduplication is fundamental to the performance of a Solid Router application.

This deduplication also applies when multiple components on the same page use the same query.
As long as a query is actively being used by one component, Solid Router will not refetch its data.
Once a query is no longer active (for example, when the user navigates away from all components that use it), the data is eventually discarded.

## Revalidation

Data on the server can change.
To prevent the UI from becoming stale, Solid Router provides powerful mechanisms for revalidation.

The most common scenario is automatic revalidation.
After a successful [action](/solid-router/concepts/actions), Solid Router automatically revalidates all active queries on the page, ensuring the UI always reflects the latest server data.
Learn more in the [actions documentation](/solid-router/concepts/actions#automatic-data-revalidation).

For more fine-grained control, revalidation can be triggered manually using the [`revalidate`](/solid-router/reference/data-apis/revalidate) function.
The `revalidate` function takes a query key (or an array of keys) to target specific queries for re-fetching.
Each query exposes two properties for this purpose: `key` and `keyFor`.

- `query.key` is the base key for the query, which targets all queries.
  Using this key will revalidate all data previously fetched by that query, regardless of the arguments used.
- `query.keyFor(arguments)` is a function that generates a key for a specific set of arguments.
  This allows for targeting and revalidating only a single, specific query.

```tsx
import { query, createAsync, revalidate } from "@solidjs/router";

const getCartQuery = query(async (userId: string) => {
	// ... Fetches a user's cart items.
}, "cart");

function CartItems(props: { userId: string }) {
	const items = createAsync(() => getCartQuery(props.userId));

	function refetchThisCart() {
		revalidate(getCartQuery.keyFor(props.userId));
	}

	function refetchAllCarts() {
		revalidate(getCartQuery.key);
	}

	return (
		<div>
			<button onClick={refetchThisCart}>Refetch this cart</button>
			<button onClick={refetchAllCarts}>Refetch all carts</button>
			<p>Items: {items()?.length}</p>
		</div>
	);
}
```

## Streaming

In a traditional server-rendered application, the user must wait for all data to be fetched on the server before the page is rendered and sent to the browser.
This can lead to a slow initial page load if some queries are slow.
Streaming solves this problem.
It allows the server to send the page's HTML shell immediately, and then "stream" the content for data-dependent sections as they become ready.

The key to enabling streaming is the [`<Suspense>`](/reference/components/suspense) component.
Each suspense boundary acts as a marker, telling the server that the content within it can be streamed separately.

When the server renders a component, and a `createAsync` signal is read within a suspense boundary, the server does not wait.
Instead, it sends the fallback UI for that boundary and continues rendering the rest of the page.
Once the data for the suspended part resolves, the server sends the final HTML for that section to the browser, which then replaces the fallback.
This allows the user to see and interact with the majority of the page much faster.

```tsx
import { Suspense, For } from "solid-js";
import { query, createAsync } from "@solidjs/router";

const getAccountStatsQuery = query(async () => {
	// ... Fetches account statistics.
}, "accountStats");

const getRecentTransactionsQuery = query(async () => {
	// ... Fetches a list of recent transactions.
}, "recentTransactions");

function AccountDashboard() {
	const stats = createAsync(() => getAccountStatsQuery());
	const transactions = createAsync(() => getRecentTransactionsQuery());

	return (
		<div>
			<h1>Account dashboard</h1>
			<Suspense fallback={<p>Loading account stats...</p>}>
				<For each={stats()}>
					{(stat) => (
						<p>
							{stat.label}: {stat.value}
						</p>
					)}
				</For>
			</Suspense>

			<Suspense fallback={<p>Loading recent transactions...</p>}>
				<For each={transactions()}>
					{(tx) => (
						<h2>
							{tx.description} - {tx.amount}
						</h2>
					)}
				</For>
			</Suspense>
		</div>
	);
}
```

In this example, the server can stream the HTML for the stats and the match history in separate chunks as soon as their respective queries are resolved.

### When to disable streaming

While streaming is a powerful default, there are scenarios where it is preferable to wait for the data on the server.
For these cases, the `deferStream` option on `createAsync` can be used.

The primary reason to disable streaming is for search engine optimization (SEO).
Some search engine crawlers may not wait for streamed content to be fully loaded.
If a piece of data is critical for SEO, such as a page title or meta description, it is best to ensure it is part of the initial server response.
Another reason is to prevent Cumulative Layout Shift (CLS).
If a large, streamed section causes a significant shift in the page layout, it may be better to render the complete component at once.

```tsx
import { createAsync, query } from "@solidjs/router";

const getFlightDetailsQuery = query(async () => {
	// ... Fetches critical flight details.
}, "flightDetails");

function FlightHeader() {
	const data = createAsync(() => getFlightDetailsQuery(), {
		deferStream: true,
	});

	return <h1>Flight {data()?.flightNumber}</h1>;
}
```

By setting `deferStream` to `true`, the server will wait for the query to resolve before sending the initial HTML.
This guarantees the data is present for crawlers and prevents the component from causing a layout shift.
