---
title: Security
---

This guide walks you through how to implement common security mechanisms in SolidStart.

## XSS (Cross Site Scripting)

Solid automatically escape values passed to JSX expressions to reduce the risk of XSS attacks.
However, this protection does not apply when using [`innerHTML`](https://docs.solidjs.com/reference/jsx-attributes/innerhtml-or-textcontent#innerhtml-or-textcontent).

To protect your application from XSS attacks:

1. Avoid using [`innerHTML`](/reference/jsx-attributes/innerhtml-or-textcontent#innerhtml-or-textcontent) when possible.
   If you must use it, sanitize the content before rendering with libraries such as [DOMPurify](https://github.com/cure53/DOMPurify).
2. Validate and sanitize user inputs.
   Always validate form inputs on the server in addition to the client.
3. Set a Content Security Policy (CSP).

We highly recommend you read [Cross Site Scripting Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html) for more guidance.

## CSP (Content Security Policy)

To configure the `Content-Security-Policy` HTTP header, you can use a [middleware](/solid-start/advanced/middleware).

### With nonce (recommended)

If you want to use a strict CSP with nonces:

1. Create a middleware that configures the CSP header, then register it to run on the [`onRequest`](/solid-start/advanced/middleware#onrequest) event.
2. Store the nonce in the [`locals`](/solid-start/advanced/middleware#locals) object.
3. Configure SolidStart to use the nonce in your [`entry-server.tsx`](/solid-start/reference/entrypoints/entry-server) file.

<TabsCodeBlocks>
<div id="Middleware">

```tsx
import { createMiddleware } from "@solidjs/start/middleware";
import { randomBytes } from "crypto";

export default createMiddleware({
	onRequest: (event) => {
		const nonce = randomBytes(16).toString("base64");

		event.locals.nonce = nonce;

		const csp = `
      default-src 'self';
      script-src 'nonce-${nonce}' 'strict-dynamic' 'unsafe-eval';
      object-src 'none';
      base-uri 'none';
      frame-ancestors 'none';
      form-action 'self';
    `.replace(/\s+/g, " ");

		event.response.headers.set("Content-Security-Policy", csp);
	},
});
```

</div>
<div id="entry-server.tsx">

```tsx {6} title="src/entry-server.tsx"
// @refresh reload
import { createHandler, StartServer } from "@solidjs/start/server";

export default createHandler(
	() => <StartServer /* ... */ />,
	(event) => ({ nonce: event.locals.nonce })
);
```

</div>
</TabsCodeBlocks>

### Without nonce

To configure CSP without a nonce, create a middleware that configures the CSP header, then register it to run on the [`onBeforeResponse`](/solid-start/advanced/middleware#onbeforeresponse) event:

```tsx
import { createMiddleware } from "@solidjs/start/middleware";

export default createMiddleware({
	onBeforeResponse: (event) => {
		const csp = `
      default-src 'self';
      font-src 'self'  ;
      object-src 'none';
      base-uri 'none';
      frame-ancestors 'none';
      form-action 'self';
    `.replace(/\s+/g, " ");

		event.response.headers.set("Content-Security-Policy", csp);
	},
});
```

## CORS (Cross-Origin Resource Sharing)

When you want to allow other applications to access your API endpoints, you can use a middleware to configure the CORS headers:

```tsx
import { createMiddleware } from "@solidjs/start/middleware";
import { json } from "@solidjs/router";

const TRUSTED_ORIGINS = ["https://my-app.com", "https://another-app.com"];

export default createMiddleware({
	onBeforeResponse: (event) => {
		const { request, response } = event;

		response.headers.append("Vary", "Origin, Access-Control-Request-Method");

		const origin = request.headers.get("Origin");
		const requestUrl = new URL(request.url);
		const isApiRequest = requestUrl && requestUrl.pathname.startsWith("/api");

		if (isApiRequest && origin && TRUSTED_ORIGINS.includes(origin)) {
			// Handle preflight requests.
			if (
				request.method === "OPTIONS" &&
				request.headers.get("Access-Control-Request-Method")
			) {
				// Preflight requests are standalone, so we immediately send a response.
				return json(null, {
					headers: {
						"Access-Control-Allow-Origin": origin,
						"Access-Control-Allow-Methods": "OPTIONS, POST, PUT, PATCH, DELETE",
						"Access-Control-Allow-Headers": "Authorization, Content-Type",
					},
				});
			}

			// Handle normal requests.
			response.headers.set("Access-Control-Allow-Origin", origin);
		}
	},
});
```

## CSRF (Cross-Site Request Forgery)

To prevent CSRF attacks, you can use a middleware to block untrusted requests:

```tsx
import { createMiddleware } from "@solidjs/start/middleware";
import { json } from "@solidjs/router";

const SAFE_METHODS = ["GET", "HEAD", "OPTIONS", "TRACE"];
const TRUSTED_ORIGINS = ["https://another-app.com"];

export default createMiddleware({
	onRequest: (event) => {
		const { request } = event;

		if (!SAFE_METHODS.includes(request.method)) {
			const requestUrl = new URL(request.url);
			const origin = request.headers.get("Origin");

			// If we have an Origin header, check it against our allowlist.
			if (origin) {
				const parsedOrigin = new URL(origin);

				if (
					parsedOrigin.origin !== requestUrl.origin &&
					!TRUSTED_ORIGINS.includes(parsedOrigin.host)
				) {
					return json({ error: "origin invalid" }, { status: 403 });
				}
			}

			// If we are serving via TLS and have no Origin header, prevent against
			// CSRF via HTTP man-in-the-middle attacks by enforcing strict Referer
			// origin checks.
			if (!origin && requestUrl.protocol === "https:") {
				const referer = request.headers.get("Referer");

				if (!referer) {
					return json({ error: "referer not supplied" }, { status: 403 });
				}

				const parsedReferer = new URL(referer);

				if (parsedReferer.protocol !== "https:") {
					return json({ error: "referer invalid" }, { status: 403 });
				}

				if (
					parsedReferer.host !== requestUrl.host &&
					!TRUSTED_ORIGINS.includes(parsedReferer.host)
				) {
					return json({ error: "referer invalid" }, { status: 403 });
				}
			}
		}
	},
});
```

This example demonstrates a basic implementation of CSRF protection that checks for the `Origin` and `Referer` headers and blocks requests that are not from trusted origins.
In addition, consider implementing a more comprehensive CSRF protection mechanism such as [Double-Submit Cookie Pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#alternative-using-a-double-submit-cookie-pattern).

We highly recommend you read [Cross-Site Request Forgery Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) for more guidance.

