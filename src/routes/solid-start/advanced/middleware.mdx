---
title: "Middleware"
---

Middleware intercepts HTTP requests and responses, enabling you to modify them for purposes like authentication, redirection, logging, and more.
It also allows you to share request-scoped data across your application using the `event.locals` object.

## Use cases

Here are some common use cases for middleware:

- **Request and Response Header Management:** Middleware allows you to add, modify, or remove headers to control caching (e.g., setting `Cache-Control` headers), enhance security (e.g., setting security headers like `Content-Security-Policy`), or implement custom behavior based on request characteristics.
- **Global Data Sharing:** Using the `event.locals` object, you can store and share request-specific data between middleware and any server-side context (API routes, server-only queries/actions). This is useful for passing information like user authentication status, feature flags, or other request-related data.
- **Server-Side Redirects:** You can redirect users based on various request properties, such as locale (e.g., redirecting users to a localized version of your site), authentication state (e.g., redirecting unauthenticated users to a login page), or custom query parameters.
- **Request Preprocessing:** Middleware can perform lightweight preprocessing tasks, such as validating tokens (e.g., JWT validation) or normalizing paths (e.g., removing trailing slashes).

While middleware is powerful, it's essential to understand its limitations.
Certain tasks are better handled in other parts of your application for performance, maintainability, or security reasons:

- **Authorization:** Middleware does _not_ run on every request, especially during client-side navigations.
  Relying on middleware for authorization would create a significant security vulnerability.
  Instead, perform authorization checks within API routes, server-only queries/actions, or other server-side utilities, as close to your data source as possible.
- **Heavy Computation or Long-Running Processes:** Middleware should be lightweight and execute quickly to avoid impacting performance.
  CPU-intensive tasks, long-running processes, or blocking operations (like complex calculations or external API calls) should be handled by dedicated route handlers, server-side utilities, or background jobs.
- **Database Operations:** Performing direct database queries within middleware can lead to performance bottlenecks and make your application harder to maintain.
  Use server-side utilities or route handlers for database interactions.
  This allows you to better manage database connections and handle potential errors.

## Basic usage

1. Create a file (e.g., `src/middleware/index.ts`) and use `createMiddleware` from `@solidjs/start/middleware` to configure your middleware.
   This file should `export default` the result:

```ts title="src/middleware/index.ts"
import { createMiddleware } from "@solidjs/start/middleware";

export default createMiddleware({
	onRequest: (event) => {
		console.log("Request received:", event.request.url);
		event.locals.startTime = Date.now();
	},
	onBeforeResponse: (event) => {
		const endTime = Date.now();
		const duration = endTime - event.locals.startTime;
		console.log(`Request took ${duration}ms`);
	},
});
```

2. In your `app.config.ts` file, use the `middleware` option to specify the path to your middleware file:

```ts
import { defineConfig } from "@solidjs/start/config";

export default defineConfig({
	middleware: "src/middleware/index.ts",
});
```

## Understanding middleware and `createMiddleware`

The functions you provide to the `onRequest` and `onBeforeResponse` properties _are_ your middleware.
`createMiddleware` takes these middleware and creates a _middleware definition_ that tells SolidStart _when_ to execute them.

## Lifecycle events

SolidStart provides two lifecycle events, `onRequest` and `onBeforeResponse`, which you use to configure when your middleware runs.
These events are configured within the object you pass to `createMiddleware`.

### `onRequest`

You use the `onRequest` event to execute middleware before your application processes the request.
This is the ideal place to:

- Perform early redirects (e.g., based on authentication or locale).
- Set or modify request headers.
- Store request-specific data in `event.locals` for use in later middleware or route handlers.

### `onBeforeResponse`

You use the `onBeforeResponse` event to execute middleware after your application has generated a response but before it is sent to the client.
This is the ideal place to:

- Modify response headers (e.g., setting caching headers).
- Log response metrics or perform other post-processing tasks.
- Modify the Response body

### The `event` object

The `event` object passed to both `onRequest` and `onBeforeResponse` provides access to the request and response objects, as well as other context related to the current request. It is of type FetchEvent.

## `event.locals`

`event.locals` provides a mechanism for sharing request-scoped data between middleware and any server-side context (e.g., API routes and server-only queries/actions).

Within middleware, you can modify the `event.locals` object.
The data persists throughout the request lifecycle and is accessible via the [`getRequestEvent`](/reference/server-utilities/get-request-event) function.

You can store any JavaScript value within `locals`, including strings, booleans, objects, functions, and even more complex data structures like Maps and Sets.

This example demonstrates how to store user information in a middleware:

```ts
import { createMiddleware } from "@solidjs/start/middleware";

export default createMiddleware({
	onRequest: (event) => {
		event.locals.user = {
			name: "John Wick",
		};

		event.locals.sayHello = () => {
			return "Hello, " + event.locals.user.name;
		};
	},
});
```

Then you can access this data in server-side code using `getRequestEvent`:

```tsx {6} title="src/routes/index.tsx"
import { getRequestEvent } from "solid-js/web";
import { query, createAsync } from "@solidjs/router";

const getUser = query(async () => {
	"use server";
	const event = getRequestEvent();
	return {
		name: event?.locals?.user?.name,
		greeting: event?.locals?.sayHello(),
	};
}, "user");

export default function Page() {
	const user = createAsync(() => getUser());

	return (
		<div>
			<p>Name: {user()?.name}</p>
			<button onClick={() => alert(user()?.greeting)}>Say Hello</button>
		</div>
	);
}
```

## Headers

You can access and modify request and response headers using the `event.request.headers` and `event.response.headers` objects.
These follow the standard Web API [`Headers`](https://developer.mozilla.org/en-US/docs/Web/API/Headers) interface, allowing you to use built-in methods for reading and updating headers.

```ts
import { createMiddleware } from "@solidjs/start/middleware";

export default createMiddleware({
	onRequest: (event) => {
		// Read a request header
		const userAgent = event.request.headers.get("user-agent");

		// Set custom request and response headers
		event.request.headers.set("x-custom-request-header", "hello");
		event.response.headers.set("x-custom-response-header1", "hello");
	},
	onBeforeResponse: (event) => {
		// Modify response headers before sending the response
		event.response.headers.set("x-custom-response-header2", "hello");
	},
});
```

## Cookies

HTTP cookies are accessible through the `Cookie` request header and `Set-Cookie` response header.
While you can manipulate these headers directly, Vinxi provides helpers to simplify cookie management.
See the [Vinxi Cookies documentation](https://vinxi.vercel.app/api/server/cookies.html) for more information.

```ts
import { createMiddleware } from "@solidjs/start/middleware";
import { getCookie, setCookie } from "vinxi/http";

export default createMiddleware({
	onRequest: (event) => {
		// Read a cookie
		const theme = getCookie(event.nativeEvent, "theme");

		// Set a cookie with options
		setCookie(event.nativeEvent, "session", "abc123", {
			httpOnly: true,
			secure: true,
			maxAge: 60 * 60 * 24, // 1 day
		});
	},
});
```

## Custom responses

Returning a value from a middleware _immediately terminates the request processing pipeline_.
This means no further middleware or route handlers will be executed, and the returned value will be sent as the response to the client.

To send a custom response, return a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object.
This gives you full control over the status code, headers, and body of the response.

For instance, you can return a plain text response with a custom status code like this:

```ts
import { createMiddleware } from "@solidjs/start/middleware";

export default createMiddleware({
	onRequest: () => {
		return new Response("Unauthorized", { status: 401 });
	},
});
```

This will immediately send a "401 Unauthorized" response with the text "Unauthorized" as the body, preventing any further processing of the request.

### Redirects

Solid-Router provides the [`redirect`](https://docs.solidjs.com/solid-router/reference/response-helpers/redirect) helper which simplifies creating redirect responses.

```ts
import { createMiddleware } from "@solidjs/start/middleware";
import { redirect } from "@solidjs/router";

const REDIRECT_MAP: Record<string, string> = {
	"/signup": "/auth/signup",
	"/login": "/auth/login",
};

export default createMiddleware({
	onRequest: (event) => {
		const { pathname } = new URL(event.request.url);

		if (pathname in REDIRECT_MAP) {
			return redirect(REDIRECT_MAP[pathname], 301); // Permanent redirect
		}
	},
});
```

This example demonstrates how to redirect users based on a predefined path mapping.
The 301 status code indicates a permanent redirect.
You can use other redirect status codes like 302 (Found) or 307 (Temporary Redirect) as needed.

## Chaining middlewares

You can pass an array of middleware to the `onRequest` and `onBeforeResponse` options in `createMiddleware`.
This allows you to compose smaller, more focused middleware, rather than handling all logic in a single, large middleware.

```ts
import { createMiddleware } from "@solidjs/start/middleware";
import { type FetchEvent } from "@solidjs/start/server";

function middleware1(event: FetchEvent) {
	event.request.headers.set("x-custom-header1", "hello-from-middleware1");
}

function middleware2(event: FetchEvent) {
	event.request.headers.set("x-custom-header2", "hello-from-middleware2");
}

export default createMiddleware({
	onRequest: [middleware1, middleware2],
});
```

## Common mistakes

### Authorization

Using middleware for authorization in SolidStart is a critical security vulnerability. Because middleware does not execute on every client-side navigation, this approach cannot reliably protect your application.

**Instead:** Always perform authorization checks as close to your data source as possible (e.g., within server-only queries and actions or API routes).
