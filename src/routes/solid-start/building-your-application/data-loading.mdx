---
title: "Data loading"
---

Efficient data loading is crucial for creating responsive web applications. SolidStart offers several approaches to fetch and manage data, achieves good performance and developer experience. This guide explores built-in primitives like `createAsync` and `createResource`, as well as integration with third-party libraries, to help you implement effective data loading strategies in your SolidStart projects.

## Using `createAsync` primitive

[`createAsync`](/solid-router/reference/data-apis/create-async) takes an asynchronous function (known as a fetcher function) and returns a signal that tracks the result of the fetcher function.

```tsx title="/routes/users/[id].tsx"
import { cache, createAsync, useParams } from "@solidjs/router";

type User = { id: string; name: string };

const getUser = cache(async (id: string) => {
	const result = await fetch(`https://my-api.com/users/${id}`);
	const user = (await result.json()) as User;
	return user;
}, "user");

export default function Page() {
	const params = useParams();
	const user = createAsync(() => getUser(params.id));
	return <div>{user()?.name}</div>;
}
```

Wrapping the fetcher function with [`cache`](/solid-router/reference/data-apis/cache) makes sure it's not called multiple times with the same argument(s). The second argument of cache is a string that uniquely describes the type of data it's fetching, in this case "user". When used with `createAsync`, `cache` will return a previously computed value if it was already computed for the given argument(s), improving performance and reducing unnecessary API calls.

### Preloading data

You can use the [`load`](/solid-router/reference/load-functions/load) function to preload a resource:

```tsx title="/routes/users/[id].tsx" {5} {16-18}
import {
	cache,
	createAsync,
	useParams,
	type RouteDefinition,
} from "@solidjs/router";

type User = { id: string; name: string };

const getUser = cache(async (id: string) => {
	const result = await fetch(`https://my-api.com/users/${id}`);
	const user = (await result.json()) as User;
	return user;
}, "user");

export const route = {
	load: ({ params }) => getUser(params.id),
} as RouteDefinition;

export default function Page() {
	const params = useParams();
	const user = createAsync(() => getUser(params.id));
	return <div>{user()?.name}</div>;
}
```

The `load` function runs in parallel with route loading. This happens when:

1. A user visits the route for the first time
2. A user hovers over a link to the route

In our example, we call `getUser` inside the `load` function. Because we use `cache`, the result is stored and becomes immediately available for future use.

### Server-only fetcher functions

Fetcher functions can be server-only. Simply add [`"use server"`](/solid-start/reference/server/use-server) to the first line of a function to ensure it runs exclusively on the server. This feature allows for safe database operations within the function.

```tsx title="/routes/users/[id].tsx" {7} {10-12}
import {
	cache,
	createAsync,
	useParams,
	type RouteDefinition,
} from "@solidjs/router";
import { db } from "~/db";

const getUser = cache(async (id: string) => {
	"use server";
	const user = await db.user.findUnique({ id });
	return user;
}, "user");

export const route = {
	load: ({ params }) => getUser(params.id),
} as RouteDefinition;

export default function Page() {
	const params = useParams();
	const user = createAsync(() => getUser(params.id));
	return <div>{user()?.name}</div>;
}
```

### Actions and automatic rerunning

One key advantage of `createAsync` is its integration with actions. When an action runs within a component where `createAsync` is used, the `createAsync` fetcher function will automatically rerun. This behavior ensures that your data stays up-to-date after mutations.

For example:

```tsx title="/routes/users/[id].tsx" {3} {16-19} {30-37}
import {
	action,
	cache,
	createAsync,
	useParams,
	type RouteDefinition,
} from "@solidjs/router";
import { db } from "~/db";

const getUser = cache(async (id: string) => {
	"use server";
	const user = await db.user.findUnique({ id });
	return user;
}, "user");

const updateUser = action(async (formData: FormData) => {
	"use server";
	const name = formData.get("name") as string;
	await db.user.findUniqueAndUpdate({ id }, { name });
});

export const route = {
	load: ({ params }) => getUser(params.id),
} as RouteDefinition;

export default function Page() {
	const params = useParams();
	const user = createAsync(() => getUser(params.id));
	return (
		<div>
			<h1>{user()?.name}</h1>
			<form action={updateUser} method="post">
				<label for="name">Name:</label>
				<input id="name" type="text" name="name" />
				<button>Update Name</button>
			</form>
		</div>
	);
}
```

In this example, when the form is submitted and the `updateUser` action runs, the `createAsync` callback will automatically rerun, fetching the updated user data.

## Using `createResource` primitive

[`createResource`](/reference/basic-reactivity/create-resource) is similar to `createAsync`, but with some key differences. It accepts a fetcher function and returns an array instead of a single value.

Here's the basic structure:

```tsx
const [data, { mutate, refetch }] = createResource(fetcherFn);
```

The returned array contains a signal (`data`) with the fetcher function's result, and an object with two methods:
	- `mutate`: Directly updates the `data` signal (it works like any other signal setter)
	- `refetch`: Reruns the fetcher function

```tsx title="/routes/users/[id].tsx"
import { createResource } from "solid-js";
import { useParams } from "@solidjs/router";

type User = { id: string; name: string };

export default function Page() {
	const params = useParams();
	const [user] = createResource(async () => {
		const result = await fetch(`https://my-api.com/users/${params.id}`);
		const user = (await result.json()) as User;
		return user;
	});
	return <div>{user()?.name}</div>;
}
```

`createResource` integrates with [`Suspense`](/reference/components/suspense) for managing loading states and works with [`ErrorBoundary`](/reference/components/error-boundary) for handling errors.

```tsx title="/routes/users/[id].tsx" {1} {14-22}
import { createResource, ErrorBoundary, Suspense } from "solid-js";
import { useParams } from "@solidjs/router";

type User = { id: string; name: string };

export default function Page() {
	const params = useParams();
	const [user] = createResource(async () => {
		const result = await fetch(`https://my-api.com/users/${params.id}`);
		const user = (await result.json()) as User;
		return user;
	});
	return (
		<div>
			{/* An error while fetching will be caught by the ErrorBoundary */}
			<ErrorBoundary fallback={<div>Something went wrong!</div>}>
				{/* Suspense will trigger a loading state while the data is being fetched */}
				<Suspense fallback={<div>Loading...</div>}>
					<div>{user()?.name}</div>
				</Suspense>
			</ErrorBoundary>
		</div>
	);
}
```

`createResource` cannot be used directly with the `cache` function.

## Using Tanstack Query

You can fetch data using data fetching libraries such as Tanstack Query. Tanstack Query provide its own APIs for caching, revalidating, and mutating data.

```tsx title="/routes/users/[id].tsx"
import { ErrorBoundary, Suspense } from "solid-js";
import { useParams } from "@solidjs/router";
import { createQuery } from "@tanstack/solid-query";

type User = { id: string; name: string };

export default function Page() {
	const params = useParams();
	const userQuery = createQuery(() => ({
		queryKey: ["user", params.id],
		queryFn: async (id) => {
			const result = await fetch(`https://my-api.com/users/${id}`);
			const user = (await result.json()) as User;
			return user;
		},
	}));
	return (
		<div>
			{/* An error while fetching will be caught by the ErrorBoundary */}
			<ErrorBoundary fallback={<div>Something went wrong!</div>}>
				{/* Suspense will trigger a loading state while the data is being fetched */}
				<Suspense fallback={<div>Loading...</div>}>
					<div>{userQuery.data?.name}</div>
				</Suspense>
			</ErrorBoundary>
		</div>
	);
}
```

## Choosing the right data loading method

Each data loading approach in SolidStart has its strengths. Here's a guide to help you choose the best method for your needs:

### `createAsync` vs `createResource` 

These primitives are closely related, with `createAsync` being a thin wrapper around `createResource`. Key differences include:

- `createAsync` integrates with the `cache` function, optimizing performance by storing results for reuse.
- `createAsync` automatically reruns when actions are triggered in the same component.
- `createResource` provides `refetch` and `mutate` functions, offering more granular control over data management.
- `createResource` doesn't have built-in integration with actions or `cache`.

Choose `createAsync` when you need automatic data refreshing after actions. Opt for `createResource` when you require more manual control over data fetching and updates.

### Relationship between `createAsync`, `cache`, and actions

`createAsync`, when used in combination with `cache` and actions, provides a powerful and convenient way to manage data in your application:

- `createAsync` automatically reruns when actions are triggered, ensuring data stays fresh.
- `cache` prevents unnecessary recomputation by storing and reusing results.
- Actions can invalidate cached data, triggering a refresh when needed.

This relationship doesn't exist for `createResource`. You would typically choose `createAsync` when you have one or more actions on a given route that could change the route data, and you want the route data to automatically update when those actions are triggered. This setup often provides a better developer experience for managing route data that's subject to mutations.

### Lazy loading considerations 

When using `createResource` in lazy-loaded components, you might encounter "waterfalls" that slow down your application. Third-party libraries like Tanstack Query can help mitigate this with hoist and cache mechanisms.

### Tanstack Query: A Powerful Alternative 

Consider Tanstack Query if you need advanced features like automatic background refetching or infinite queries. It's particularly appealing if you're already familiar with it from other projects. However, keep in mind that it will increase your bundle size slightly.

Ultimately, your choice should align with your project's complexity, performance requirements, and your team's expertise. Consider starting with built-in methods for smaller projects and exploring third-party options as your needs grow more complex.
